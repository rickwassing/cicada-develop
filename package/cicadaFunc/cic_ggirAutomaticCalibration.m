function ACT = cic_ggirAutomaticCalibration(ACT)
% ---------------------------------------------------------
% Algorithm based on Dr. Zhou Fang's code for auto-calibration
% functionality in GGIR.
% Reference:
% van Hees VT, Fang Z, et al. Auto-calibration of accelerometer data for 
%   free-living physical activity assessment using local gravity and 
%   temperature: an evaluation on four continents. J Appl Physiol 2014.
% ---------------------------------------------------------
% some settings
minLoadCriterion = 72;
sdCriterion      = 0.013;
sphereCriterion  = 0.3;
windowLength     = 10;
maxIter          = 1000;
tolerance        = 1e-10;
if ~isfield(ACT.data.temperature, 'wrist')
    useTemp = false;
else
    useTemp = true;
end
% ---------------------------------------------------------
% Is there enough data to populate the sphere?
if length(ACT.data.acceleration.x.Data) <= minLoadCriterion-21
    return
end

meta = table();
meta.GxM = averagePerWindow(ACT.data.acceleration.x.Data, ACT.srate, windowLength)';
meta.GyM = averagePerWindow(ACT.data.acceleration.y.Data, ACT.srate, windowLength)';
meta.GzM = averagePerWindow(ACT.data.acceleration.z.Data, ACT.srate, windowLength)';
meta.GxSD = stdPerWindow(ACT.data.acceleration.x.Data, ACT.srate, windowLength)';
meta.GySD = stdPerWindow(ACT.data.acceleration.y.Data, ACT.srate, windowLength)';
meta.GzSD = stdPerWindow(ACT.data.acceleration.z.Data, ACT.srate, windowLength)';
if useTemp
    meta.temperatureM = averagePerWindow(ACT.data.temperature.wrist.Data, ACT.srate, windowLength)';
end
meta(1,:) = [];

% TODO, check if the value 2 is in g or mg
noMovementIdx = ...
    meta.GxSD < sdCriterion & ...
    meta.GySD < sdCriterion & ...
    meta.GzSD < sdCriterion & ...
    abs(meta.GxM) < 2 & ...
    abs(meta.GyM) < 2 & ...
    abs(meta.GzM) < 2;

meta = meta(noMovementIdx,:);

if min(size(meta)) == 1
    return
end

calErrorStart = sqrt(meta.GxM.^2 + meta.GyM.^2 + meta.GzM.^2);
calErrorStart = mean(abs(calErrorStart - 1));
% ---------------------------------------------------------
% check whether sphere is well populated
if ~( ...
    min(meta.GxM) < -sphereCriterion && max(meta.GxM) > sphereCriterion && ...
    min(meta.GyM) < -sphereCriterion && max(meta.GyM) > sphereCriterion && ...
    min(meta.GzM) < -sphereCriterion && max(meta.GzM) > sphereCriterion)
    return
end
% ---------------------------------------------------------
% START of Zhou Fang's code, slightly edited by vtv21 to use 'meta' from above
% instead the similar matrix generated by Zhou Fang's original code. This to allow for
% more data to be used as 'meta' can now be based on 10 or more days of raw data.

inputAct = [meta.GxM, meta.GyM, meta.GzM];

if useTemp
    inputTemp = [meta.temperatureM, meta.temperatureM, meta.temperatureM];
else
    inputTemp = zeros(size(meta,1),3); % temperature, here used as a dummy variable
end
inputTemp = inputTemp - nanmean(inputTemp(:,1));

actOffset  = zeros(1, size(inputAct,2));
tempOffset = zeros(1, size(inputAct,2));
scale      = ones(1, size(inputAct,2));
weights    = ones(1,size(inputAct,1));
residuals  = Inf;

for iter = 1:maxIter
    
    curr = ...
        removeOffsetGain(inputAct, -actOffset, 1./scale) + ...
        removeOffsetGain(inputTemp, false, 1./tempOffset);
    
    if size(curr,1) == 0
        break
    end
    
    closestPoint    = curr ./ repmat(sqrt(sum(curr.^2,2)),1,size(curr,2));
    deltaActOffset  = zeros(1, size(inputAct,2));
    deltaScale      = ones(1, size(inputAct,2));
    deltaTempOffset = zeros(1, size(inputTemp,2));
    
    for k = 1:size(inputAct,2)
        if ... % deal with NaN values in some of the sphere data for Actigraph monitor brand
            strcmpi(ACT.info.device, 'actigraph') && ...
            any(isnan(closestPoint(:,k))) && ...
            sum(~isnan(closestPoint(:,k))) > 10
            % Remove those NaN entries
            closestPoint(isnan(closestPoint(:,k)),:) = [];
            curr(isnan(closestPoint(:,k)),:) = [];
            inputTemp(isnan(closestPoint(:,k)),:) = [];
            inputAct(isnan(closestPoint(:,k)),:) = [];
            weights(isnan(closestPoint(:,k)),:) = [];
        end
        
        mdl = fitlm([curr(:,k), inputTemp(:,k)], closestPoint(:,k), 'Weights', weights);
        
        deltaActOffset(k) = mdl.Coefficients.Estimate(1);
        deltaScale(k)     = mdl.Coefficients.Estimate(2);
        if useTemp
            deltaTempOffset(k) = mdl.Coefficients.Estimate(3);
        end
        
        curr(:,k) = mdl.Fitted;
    
    end
    
    actOffset = actOffset + deltaActOffset ./ (scale .* deltaScale);
    if useTemp
        tempOffset = tempOffset .* deltaScale + deltaTempOffset;
    end
    
    scale     = scale .* deltaScale;
    residuals = [residuals,  3 * mean(weights * ((curr-closestPoint).^2) / sum(weights))];
    weights   = min([1 ./ sqrt(sum((curr-closestPoint).^2,2)), ones(size(curr,1),1).*1/0.01],[],2)';
    
    if abs(residuals(iter+1) - residuals(iter)) < tolerance
        break
    end
    
end
if ~useTemp
    meta = removeOffsetGain(meta{:,1:3}, -actOffset, 1./scale);
else
    temp = [meta.temperatureM, meta.temperatureM, meta.temperatureM];
    meta = ...
        removeOffsetGain(meta{:,1:3}, -actOffset, 1./scale) + ...
        removeOffsetGain(temp, mean(temp), 1./tempOffset);
end

% END of Zhou Fang's code
% ---------------------------------------------------------

calErrorEnd = sqrt(meta(:,1).^2 + meta(:,2).^2 + meta(:,3).^2);
calErrorEnd = mean(abs(calErrorEnd-1));

if calErrorEnd > calErrorStart
    return
end
% ---------------------------------------------------------
% Now all is well, and we can calibrate the data
ACT.etc.cal.x_gain = scale(1);
ACT.etc.cal.y_gain = scale(2);
ACT.etc.cal.z_gain = scale(3);
ACT.etc.cal.x_offset = actOffset(1);
ACT.etc.cal.y_offset = actOffset(2);
ACT.etc.cal.z_offset = actOffset(3);

ACT.data.acceleration.x.Data = (ACT.data.acceleration.x.Data - ACT.etc.cal.x_offset) ./ ACT.etc.cal.x_gain;
ACT.data.acceleration.y.Data = (ACT.data.acceleration.y.Data - ACT.etc.cal.y_offset) ./ ACT.etc.cal.y_gain;
ACT.data.acceleration.z.Data = (ACT.data.acceleration.z.Data - ACT.etc.cal.z_offset) ./ ACT.etc.cal.z_gain;
% ---------------------------------------------------------
% Set saved to false
ACT.saved = false;
% ---------------------------------------------------------
% Update the pipeline
ACT = cic_updatePipe(ACT, 'preproc');
% ---------------------------------------------------------
% Write history
ACT.history = char(ACT.history, '% ---------------------------------------------------------');
ACT.history = char(ACT.history, '% GGIR''s Automatic calibration algorithm (DOI: 10.1152/japplphysiol.00421.2014)');
ACT.history = char(ACT.history, 'ACT = cic_ggirAutomaticCalibration(ACT);');

end % EOF
