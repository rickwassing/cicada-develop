function app_constructDataExcerpt(app, panel, StartDate, EndDate)

panel.Title = [datestr(StartDate, 'ddd dd/mm/yyyy HH:MM'), ' - ', datestr(EndDate, 'ddd dd/mm/yyyy HH:MM')];
% Loop over all the axes types ...
axesTypes = [{'events'}; {'acceleration'}; app.MainApp.ACT.display.order];
% Get the unitheight for each axes
axesHeightUnit = 300 / (length(axesTypes)+1);

for ai = 1:length(axesTypes)
    % ... mount/construct the axes
    % ---------------------------------------------------------
    % UIAxes
    % -----
    % Get the YLim and YScale, and Position
    switch axesTypes{ai}
        case 'events'
            YLim = [0, 1];
            YScale = 'linear';
            Position = [1, 1, 595, axesHeightUnit];
        case 'acceleration'
            add = ifelse(strcmpi(app.MainApp.ACT.display.acceleration.view, 'angle'), 360, 0);
            YLim = [app.MainApp.ACT.display.(axesTypes{ai}).range(1) + add, app.MainApp.ACT.display.(axesTypes{ai}).range(2) + add];
            YScale = ifelse(app.MainApp.ACT.display.(axesTypes{ai}).log == 0, 'linear', 'log');
            Position = [1, Position(2)+Position(4)+1, 595, axesHeightUnit*2];
        otherwise
            YLim = [app.MainApp.ACT.display.(axesTypes{ai}).range(1), app.MainApp.ACT.display.(axesTypes{ai}).range(2)];
            YScale = ifelse(app.MainApp.ACT.display.(axesTypes{ai}).log == 0, 'linear', 'log');
            Position = [1, Position(2)+Position(4)+1, 595, axesHeightUnit];
    end
    % Get XTick Steps
    if (EndDate-StartDate) <= 0.5/24 % if selection is less than 30 minutes
        step = 1/(24*60); % step is 1 minute
    elseif (EndDate-StartDate) <= 1/24 % if selection is less than an hour
        step = 2/(24*60); % step is 2 minutes
    elseif (EndDate-StartDate) <= 2/24 % if selection is less than two hours
        step = 5/(24*60); % step is 5 minutes
    elseif (EndDate-StartDate) <= 3/24 % if selection is less than three hours
        step = 10/(24*60); % step is 10 minutes
    elseif (EndDate-StartDate) <= 6/24 % if selection is less than six hours
        step = 15/(24*60); % step is 15 minutes
    elseif (EndDate-StartDate) <= 12/24 % if selection is less than 12 hours
        step = 30/(24*60); % step is 30 minutes
    elseif (EndDate-StartDate) <= 1 % if selection is less than 1 day
        step = 1/24; % step is one hour
    elseif (EndDate-StartDate) <= 2 % if selection is less than 2 days
        step = 2/24; % step is two hours
    elseif (EndDate-StartDate) <= 4 % if selection is less than 4 days
        step = 4/24; % step is four hours
    elseif (EndDate-StartDate) <= 6 % if selection is less than 6 days
        step = 6/24; % step is six hours
    elseif (EndDate-StartDate) <= 12 % if selection is less than 12 days
        step = 12/24; % step is twelve hours
    else
        step = 1; % step is one day
    end
    if shouldComponentMount(app.MainApp, panel, ['Axis_type-', axesTypes{ai}])
        % Define the properties
        props = {...
            'Tag', ['Axis_type-', axesTypes{ai}]; ...
            'XLim', [StartDate-step, EndDate+step]; ...
            'XTick', ceil(StartDate*(1/step))/(1/step):step:floor(EndDate*(1/step))/(1/step); ...
            'XTickLabel', ifelse(strcmpi(axesTypes{ai}, 'events'), datestr(ceil(StartDate*(1/step))/(1/step):step:floor(EndDate*(1/step))/(1/step), 'HH:MM'), []); ...
            'XColor', [0.65, 0.68, 0.70]; ...
            'XGrid', 'on'; ...
            'GridColor', [0.65, 0.68, 0.70]; ...
            'GridAlpha', 0.5; ...
            'YLim', YLim; ...
            'YTick', []; ...
            'YScale', YScale; ...
            'YColor', [0.98, 0.98, 0.98]; ...
            'Color', [1, 1, 1]; ...
            'ColorOrder', mount_colororder(); ...
            'BackgroundColor', [0.97, 0.97, 0.97]; ...
            'FontSize', 8; ...
            'Position', Position; ...
            'Layer', 'top'; ...
            'Visible', ifelse(Position(4) == 5, 'off', 'on'); ...
            'Box', 'on'; ...
            };
        % Mount component using the 'mount_uiaxes' function
        ax = mountComponent(app.MainApp, 'mount_uiaxes', panel, props);
    else
        % Extract axes object
        ax = findobj(panel, 'Tag', ['Axis_type-', axesTypes{ai}]);
        % Update the component with its updated XLim
        updateComponent(app.MainApp, ax, { ...
            'XLim', [StartDate-step, EndDate+step]; ...
            'XTick', ceil(StartDate*(1/step))/(1/step):step:floor(EndDate*(1/step))/(1/step); ...
            'XTickLabel', ifelse(strcmpi(axesTypes{ai}, 'events'), datestr(ceil(StartDate*(1/step))/(1/step):step:floor(EndDate*(1/step))/(1/step), 'HH:MM'), []); ...
            });
    end
    % ... and mount/construct its respective components
    switch axesTypes{ai}
        % ---------------------------------------------------------
        % Case 1: axes contain events
        case 'events'
            % Extract all events from this start to end date
            events = selectEventsUsingTime(app.MainApp.ACT.analysis.events, StartDate-step, EndDate+step, 'Enclosed', false);
            % -----
            % For each event ...
            for ei = 1:size(events, 1)
                % ... mount/construct a patch component
                if strcmpi(events.label{ei}, 'start')
                    continue
                else
                    % -----
                    % Patch Events
                    % -----
                    if shouldComponentMount(app.MainApp, ax, ['Event_id-' num2str(events.id(ei))])
                        % Get properties that need more elaborate calculation
                        [Visible, ~, Color, UserData] = app_getEventPatchProps(app.MainApp, 999, events(ei, :));
                        % Set XData
                        XData = [...
                            events.onset(ei), ...
                            events.onset(ei), ...
                            events.onset(ei)+events.duration(ei), ...
                            events.onset(ei)+events.duration(ei) ...
                            ];
                        % Define the properties
                        props = {...
                            'Tag', ['Event_id-' num2str(events.id(ei))]; ...
                            'XData', ifelse(events.duration(ei) == 0, XData(1), XData); ...
                            'YData', ifelse(events.duration(ei) == 0, 0.5, [0, 1, 1, 0]); ...
                            'Marker', ifelse(events.duration(ei) == 0, 'v', 'none'); ...
                            'FaceColor', Color; ...
                            'EdgeColor', Color; ...
                            'MarkerFaceColor', Color; ...
                            'Visible', Visible; ...
                            'PickableParts', 'none'; ...
                            'UserData', UserData; ...
                            'LineStyle', '-'; ...
                            'LineWidth', 1; ...
                            'MarkerEdgeColor', [1, 1, 1]; ...
                            };
                        % Mount component using the 'mount_patch' function
                        mountComponent(app.MainApp, 'mount_patch', ax, props);
                    end
                end
            end
            % If any new components were mounted, we'll have to re-order them
            reorderPlotEvents(app.MainApp, ax);
            % ---------------------------------------------------------
            % Case 2: axes contain acceleration and annotation
        case 'acceleration'
            % ---------------------------------------------------------
            % Annotation
            % If annotation data exists ...
            if isfield(app.MainApp.ACT.analysis.annotate, 'acceleration')
                % ... Plot the annotation data at each intensity level
                for intensity = 4:-1:1
                    if shouldComponentMount(app.MainApp, ax, ['PatchAnnotationAcceleration_int-' num2str(intensity)])
                        % Get properties that need more elaborate calculation
                        [XData, YData, Color] = app_getAnnotationPatchProps(app.MainApp, 'acceleration', intensity, 4, StartDate-step, EndDate+step);
                        % Define the properties
                        props = { ...
                            'Tag', ['PatchAnnotationAcceleration_int-' num2str(intensity)]; ...
                            'XData', XData; ...
                            'YData', YData; ...
                            'FaceColor', Color; ...
                            'LineStyle', '-'; ...
                            'LineWidth', 1; ...
                            'EdgeColor', 'none'; ...
                            'PickableParts', 'none'; ...
                            };
                        % Mount component using the 'mount_patch' function
                        mountComponent(app.MainApp, 'mount_patch', ax, props);
                        % Make sure this annotation object is on the bottom of the axis parent
                        ax.Children = [ax.Children(2:end); ax.Children(1)];
                    else
                        % Find object
                        cmp = findobj(ax, 'Tag', ['PatchAnnotationAcceleration_int-' num2str(intensity)]);
                        % Get properties that need more elaborate calculation
                        [XData, YData] = app_getAnnotationPatchProps(app.MainApp, 'acceleration', intensity, 4, StartDate-step, EndDate+step);
                        % Update the component with its updated XData
                        updateComponent(app.MainApp, cmp, { ...
                            'XData', XData; ...
                            'YData', YData; ...
                            });
                    end
                end
            end
            % ---------------------------------------------------------
            % Acceleration
            % -----
            % Counts
            % -----
            if shouldComponentMount(app.MainApp, ax, 'PatchCounts')
                % Set X and YData
                [YData, XData] = selectDataUsingTime(app.MainApp.ACT.metric.acceleration.counts.Data, app.MainApp.ACT.metric.acceleration.counts.Time, StartDate-step, EndDate+step);
                if isempty(YData) || isempty(XData)
                    XData = nan;
                    YData = nan;
                end
                YData(end) = NaN;
                % Define the properties
                props = { ...
                    'Tag', 'PatchCounts'; ...
                    'XData', XData; ...
                    'YData', YData+1; ...
                    'CData', [YData(2:end)+1; YData(end)]; ...
                    'Visible', ifelse(strcmpi(app.MainApp.ACT.display.acceleration.view, 'counts'), 'on', 'off'); ...
                    'EdgeColor', 'flat'; ...
                    'LineWidth', 1; ...
                    'Marker', 'none'; ...
                    'CDataMapping', 'scaled'; ...
                    'PickableParts', 'none'; ...
                    };
                % Mount component using the 'mount_patch' function
                mountComponent(app.MainApp, 'mount_patch', ax, props);
            else
                % Find object
                cmp = findobj(ax, 'Tag', 'PatchCounts');
                % Set X and YData
                [YData, XData] = selectDataUsingTime(app.MainApp.ACT.metric.acceleration.counts.Data, app.MainApp.ACT.metric.acceleration.counts.Time, StartDate-step, EndDate+step);
                if isempty(YData) || isempty(XData)
                    XData = nan;
                    YData = nan;
                end
                YData(end) = NaN;
                % Update the component with its updated XData
                updateComponent(app.MainApp, cmp, { ...
                    'XData', XData; ...
                    'YData', YData+1; ...
                    'CData', [YData(2:end)+1; YData(end)]; ...
                    });
            end
            % -----
            % Euclidean Norm
            % -----
            if shouldComponentMount(app.MainApp, ax, 'PatchEuclNorm')
                % Set X and YData
                [YData, XData] = selectDataUsingTime(app.MainApp.ACT.metric.acceleration.bpFiltEuclNorm.Data, app.MainApp.ACT.metric.acceleration.bpFiltEuclNorm.Time, StartDate-step, EndDate+step);
                if isempty(YData) || isempty(XData)
                    XData = nan;
                    YData = nan;
                end
                YData(end) = NaN;
                % Define the properties
                props = { ...
                    'Tag', 'PatchEuclNorm'; ...
                    'XData', XData; ...
                    'YData', YData; ...
                    'CData', [YData(2:end); YData(end)]; ...
                    'Visible', ifelse(strcmpi(app.MainApp.ACT.display.acceleration.view, 'euclNorm'), 'on', 'off'); ...
                    'EdgeColor', 'flat'; ...
                    'LineWidth', 1; ...
                    'Marker', 'none'; ...
                    'CDataMapping', 'scaled'; ...
                    'PickableParts', 'none'; ...
                    };
                % Mount component using the 'mount_patch' function
                mountComponent(app.MainApp, 'mount_patch', ax, props);
            else
                % Find object
                cmp = findobj(ax, 'Tag', 'PatchEuclNorm');
                % Set X and YData
                [YData, XData] = selectDataUsingTime(app.MainApp.ACT.metric.acceleration.bpFiltEuclNorm.Data, app.MainApp.ACT.metric.acceleration.bpFiltEuclNorm.Time, StartDate-step, EndDate+step);
                if isempty(YData) || isempty(XData)
                    XData = nan;
                    YData = nan;
                end
                YData(end) = NaN;
                % Update the component with its updated XData
                updateComponent(app.MainApp, cmp, { ...
                    'XData', XData; ...
                    'YData', YData; ...
                    'CData', [YData(2:end); YData(end)]; ...
                    });
            end
            % -----
            % Angle
            % -----
            if shouldComponentMount(app.MainApp, ax, 'PatchAngle')
                % Set X and YData
                [YData, XData] = selectDataUsingTime(app.MainApp.ACT.metric.acceleration.angle_z.Data, app.MainApp.ACT.metric.acceleration.angle_z.Time, StartDate-step, EndDate+step);
                if isempty(YData) || isempty(XData)
                    XData = nan;
                    YData = nan;
                end
                YData(end) = NaN;
                % Define the properties
                props = { ...
                    'Tag', 'PatchAngle'; ...
                    'XData', XData; ...
                    'YData', YData+360; ...
                    'CData', [0; abs(diff([YData(2:end); YData(end)]))]; ...
                    'Visible', ifelse(strcmpi(app.MainApp.ACT.display.acceleration.view, 'angle'), 'on', 'off'); ...
                    'EdgeColor', 'flat'; ...
                    'LineWidth', 1; ...
                    'Marker', 'none'; ...
                    'CDataMapping', 'scaled'; ...
                    'PickableParts', 'none'; ...
                    };
                % Mount component using the 'mount_patch' function
                mountComponent(app.MainApp, 'mount_patch', ax, props);
            else
                % Find object
                cmp = findobj(ax, 'Tag', 'PatchAngle');
                % Set X and YData
                [YData, XData] = selectDataUsingTime(app.MainApp.ACT.metric.acceleration.angle_z.Data, app.MainApp.ACT.metric.acceleration.angle_z.Time, StartDate-step, EndDate+step);
                if isempty(YData) || isempty(XData)
                    XData = nan;
                    YData = nan;
                end
                YData(end) = NaN;
                % Update the component with its updated XData
                updateComponent(app.MainApp, cmp, { ...
                    'XData', XData; ...
                    'YData', YData+360; ...
                    'CData', [0; abs(diff([YData(2:end); YData(end)]))]; ...
                    });
            end
        % ---------------------------------------------------------
        % Otherwise: axes contain other data types, e.g. light and temerature
        otherwise
            % ---------------------------------------------------------
            % Annotation
            % If annotation data exists ...
            if isfield(app.MainApp.ACT.analysis.annotate, axesTypes{ai})
                % ... Plot the annotation data at each intensity level
                intLvls = unique(app.MainApp.ACT.analysis.annotate.(axesTypes{ai}).Data);
                intLvls(intLvls == 0) = [];
                intLvls(isnan(intLvls)) = [];
                for intensity = max(intLvls):-1:min(intLvls)
                    if shouldComponentMount(app.MainApp, ax, ['PatchAnnotation' titleCase(axesTypes{ai}) '_int-' num2str(intensity)])
                        % Get properties that need more elaborate calculation
                        [XData, YData, Color] = app_getAnnotationPatchProps(app.MainApp, axesTypes{ai}, intensity, length(intLvls), StartDate-step, EndDate+step);
                        % Define the properties
                        props = { ...
                            'Tag', ['PatchAnnotation' titleCase(axesTypes{ai}) '_int-' num2str(intensity)]; ...
                            'XData', XData; ...
                            'YData', YData; ...
                            'FaceColor', Color; ...
                            'LineStyle', '-'; ...
                            'LineWidth', 1; ...
                            'EdgeColor', 'none'; ...
                            'PickableParts', 'none'; ...
                            };
                        % Mount component using the 'mount_patch' function
                        mountComponent(app.MainApp, 'mount_patch', ax, props);
                        % Make sure this annotation object is on the bottom of the axis parent
                        ax.Children = [ax.Children(2:end); ax.Children(1)];
                    else
                        % Find object
                        cmp = findobj(ax, 'Tag', ['PatchAnnotation' titleCase(axesTypes{ai}) '_int-' num2str(intensity)]);
                        % Get properties that need more elaborate calculation
                        [XData, YData] = app_getAnnotationPatchProps(app.MainApp, axesTypes{ai}, intensity, length(intLvls), StartDate-step, EndDate+step);
                        % Update the component with its updated XData
                        updateComponent(app.MainApp, cmp, { ...
                            'XData', XData; ...
                            'YData', YData; ...
                            });
                    end
                end
            end
            % ---------------------------------------------------------
            % Data
            % -----
            % Get what fields exist in this data type
            fnames = fieldnames(app.MainApp.ACT.metric.(axesTypes{ai}));
            % For each field ...
            for fi = 1:length(fnames)
                % ... mount/construct a line plot
                % -----
                if shouldComponentMount(app.MainApp, ax, ['PlotData-', axesTypes{ai}, '_field-', fnames{fi}])
                    % Set X and YData
                    [YData, XData] = selectDataUsingTime(app.MainApp.ACT.metric.(axesTypes{ai}).(fnames{fi}).Data, app.MainApp.ACT.metric.(axesTypes{ai}).(fnames{fi}).Time, StartDate-step, EndDate+step);
                    if isempty(YData)
                        continue
                    end
                    % If the minimum value is zero or smaller, add 0.0001 so the log-scale does not get to -infinity
                    YData = ifelse(min(YData) <= 0, YData+0.0001, YData);
                    % Define the properties
                    props = { ...
                        'Tag', ['PlotData-', axesTypes{ai}, '_field-', fnames{fi}]; ...
                        'XData', XData; ...
                        'YData', YData; ...
                        'Visible', ifelse(app.MainApp.ACT.display.(axesTypes{ai}).field.(fnames{fi}).show, 'on', 'off'); ...
                        'Color', app.MainApp.ACT.display.(axesTypes{ai}).field.(fnames{fi}).clr;
                        'LineWidth', 1; ...
                        };
                    % Mount component using the 'mount_plot' function
                    mountComponent(app.MainApp, 'mount_plot', ax, props);
                else
                    % Find object
                    cmp = findobj(ax, 'Tag', ['PlotData-', axesTypes{ai}, '_field-', fnames{fi}]);
                    % Set X and YData
                    [YData, XData] = selectDataUsingTime(app.MainApp.ACT.metric.(axesTypes{ai}).(fnames{fi}).Data, app.MainApp.ACT.metric.(axesTypes{ai}).(fnames{fi}).Time, StartDate-step, EndDate+step);
                    if isempty(YData)
                        continue
                    end
                    % If the minimum value is zero or smaller, add 0.0001 so the log-scale does not get to -infinity
                    YData = ifelse(min(YData) <= 0, YData+0.0001, YData);
                    % Update the component with its updated XData
                    updateComponent(app.MainApp, cmp, { ...
                        'XData', XData; ...
                        'YData', YData; ...
                        });
                end
            end 
    end
    % -----
    % Patch Interval
    % -----
    if shouldComponentMount(app.MainApp, ax, ['Interval_axis-', axesTypes{ai}])
        % Define the properties
        XData = [StartDate, StartDate, EndDate, EndDate];
        YData = ifelse(strcmpi(ax.YScale, 'log'), ...
            [0.0001, ax.YLim(2)*2, ax.YLim(2)*2, 0.0001], ...
            [ax.YLim(1)-ax.YLim(2), ax.YLim(2)*2, ax.YLim(2)*2, ax.YLim(1)-ax.YLim(2)]);
        props = { ...
            'Tag', ['Interval_axis-', axesTypes{ai}]; ...
            'XData', XData; ...
            'YData', YData; ...
            'EdgeColor', [0.1765, 0.3725, 0.6745]; ...
            'FaceColor', [0.1765, 0.3725, 0.6745]; ...
            'FaceAlpha', 0.1; ...
            'LineStyle', '-'; ...
            'LineWidth', 2; ...
            };
        % Mount component using the 'mount_patch' function
        mountComponent(app.MainApp, 'mount_patch', ax, props);
    else
        % Find object
        cmp = findobj(ax, 'Tag', ['Interval_axis-', axesTypes{ai}]);
        % Define the properties
        XData = [StartDate, StartDate, EndDate, EndDate];
        % Update the component with its updated XData
        updateComponent(app.MainApp, cmp, { ...
            'XData', XData; ...
            });
    end
end

end