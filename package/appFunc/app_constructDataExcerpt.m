function app_constructDataExcerpt(app, panel, StartDate, EndDate)

panel.Title = [datestr(StartDate, 'ddd dd/mm/yyyy HH:MM'), ' - ', datestr(EndDate, 'ddd dd/mm/yyyy HH:MM')];
% Main Positions
mainPositions = cell2mat(ascolumn({app.MainApp.Interval.Parents(1).Children.Position}));
posh = mainPositions(:, 4) / sum(mainPositions(:, 4))*195;
posy = flipud(cumsum(flipud(posh)));
posy = [posy(2:end); 1];

% Loop over all the axes types ...
axesTypes = [{'events'}; {'acceleration'}; app.MainApp.ACT.display.order];
for ai = 1:length(axesTypes)
    % ... mount/construct the axes
    % ---------------------------------------------------------
    % UIAxes
    % -----
    % Get position
    Position = [1, posy(end-ai+1), 780, posh(end-ai+1)];
    % Get the YLim and YScale
    switch axesTypes{ai}
        case 'events'
            YLim = [0, 1];
            YScale = 'linear';
        case 'acceleration'
            add = ifelse(strcmpi(app.MainApp.ACT.display.acceleration.view, 'angle'), 360, 0);
            YLim = [app.MainApp.ACT.display.(axesTypes{ai}).range(1) + add, app.MainApp.ACT.display.(axesTypes{ai}).range(2) + add];
            YScale = ifelse(app.MainApp.ACT.display.(axesTypes{ai}).log == 0, 'linear', 'log');
        otherwise
            YLim = [app.MainApp.ACT.display.(axesTypes{ai}).range(1), app.MainApp.ACT.display.(axesTypes{ai}).range(2)];
            YScale = ifelse(app.MainApp.ACT.display.(axesTypes{ai}).log == 0, 'linear', 'log');
    end
    % Get XTick Steps
    if (EndDate-StartDate) <= 0.5/24 % if selection is less than 30 minutes
        step = 1/(24*60); % step is 1 minute
    elseif (EndDate-StartDate) <= 1/24 % if selection is less than an hour
        step = 2/(24*60); % step is 2 minutes
    elseif (EndDate-StartDate) <= 2/24 % if selection is less than two hours
        step = 5/(24*60); % step is 5 minutes
    elseif (EndDate-StartDate) <= 3/24 % if selection is less than three hours
        step = 10/(24*60); % step is 10 minutes
    elseif (EndDate-StartDate) <= 6/24 % if selection is less than six hours
        step = 15/(24*60); % step is 15 minutes
    elseif (EndDate-StartDate) <= 12/24 % if selection is less than 12 hours
        step = 30/(24*60); % step is 30 minutes
    elseif (EndDate-StartDate) <= 1 % if selection is less than 1 day
        step = 1/24; % step is one hour
    elseif (EndDate-StartDate) <= 2 % if selection is less than 2 days
        step = 2/24; % step is two hours
    elseif (EndDate-StartDate) <= 4 % if selection is less than 4 days
        step = 4/24; % step is four hours
    elseif (EndDate-StartDate) <= 6 % if selection is less than 6 days
        step = 6/24; % step is six hours
    elseif (EndDate-StartDate) <= 12 % if selection is less than 12 days
        step = 12/24; % step is twelve hours
    else
        step = 1; % step is one day
    end
    % Define the properties
    props = {...
        'Tag', ['Axis_type-', axesTypes{ai}]; ...
        'XLim', [StartDate, EndDate]; ...
        'XTick', ceil(StartDate*(1/step)+1)/(1/step):step:floor(EndDate*(1/step)-1)/(1/step); ...
        'XTickLabel', ifelse(strcmpi(axesTypes{ai}, 'events'), datestr(ceil(StartDate*(1/step)+1)/(1/step):step:floor(EndDate*(1/step)-1)/(1/step), 'HH:MM'), []); ...
        'XColor', [0.65, 0.68, 0.70]; ...
        'XGrid', 'on'; ...
        'GridColor', [0.65, 0.68, 0.70]; ...
        'GridAlpha', 0.5; ...
        'YLim', YLim; ...
        'YTick', []; ...
        'YScale', YScale; ...
        'YColor', [0.98, 0.98, 0.98]; ...
        'Color', [1, 1, 1]; ...
        'ColorOrder', mount_colororder(); ...
        'BackgroundColor', [0.97, 0.97, 0.97]; ...
        'FontSize', 8; ...
        'Position', Position; ...
        'Layer', 'top'; ...
        'Visible', ifelse(Position(4) == 5, 'off', 'on'); ...
        'Box', 'on'; ...
        };
    % Mount component using the 'mount_uiaxes' function
    ax = mountComponent(app.MainApp, 'mount_uiaxes', panel, props);
    
    % ... and mount/construct its respective components
    switch axesTypes{ai}
        % ---------------------------------------------------------
        % Case 1: axes contain events
        case 'events'
            % Extract all events from this start to end date
            events = selectEventsUsingTime(app.MainApp.ACT.events, StartDate, EndDate, 'Enclosed', false);
            % -----
            % For each event ...
            for ei = 1:size(events, 1)
                % ... mount/construct a patch component
                if strcmpi(events.label{ei}, 'start')
                    continue
                    % Check if component should mount
                else
                    % Get properties that need more elaborate calculation
                    [Visible, ~, Color, UserData] = app_getEventPatchProps(app.MainApp, 999, events(ei, :));
                    % Set XData
                    XData = [...
                        events.onset(ei), ...
                        events.onset(ei), ...
                        events.onset(ei)+events.duration(ei), ...
                        events.onset(ei)+events.duration(ei) ...
                        ];
                    % Define the properties
                    props = {...
                        'Tag', ['Event_id-' num2str(events.id(ei))]; ...
                        'XData', ifelse(events.duration(ei) == 0, XData(1), XData); ...
                        'YData', ifelse(events.duration(ei) == 0, 0.5, [0, 1, 1, 0]); ...
                        'Marker', ifelse(events.duration(ei) == 0, 'v', 'none'); ...
                        'FaceColor', Color; ...
                        'EdgeColor', Color; ...
                        'MarkerFaceColor', Color; ...
                        'Visible', Visible; ...
                        'PickableParts', 'none'; ...
                        'UserData', UserData; ...
                        'LineStyle', '-'; ...
                        'LineWidth', 1; ...
                        'MarkerEdgeColor', [1, 1, 1]; ...
                        };
                    % Mount component using the 'mount_patch' function
                    mountComponent(app.MainApp, 'mount_patch', ax, props);
                end
            end
            % If any new components were mounted, we'll have to re-order them
            reorderPlotEvents(app.MainApp, ax);
            
            % ---------------------------------------------------------
            % Case 2: axes contain acceleration and annotation
        case 'acceleration'
            % ---------------------------------------------------------
            % Annotation
            % If annotation data exists ...
            if any(app.MainApp.ACT.analysis.annotate.Data ~= 0)
                % ... Plot the annotation data at each intensity level
                for intensity = 3:-1:0
                    % Get properties that need more elaborate calculation
                    [XData, YData, Color] = app_getAnnotationPatchProps(app.MainApp, intensity, StartDate, EndDate);
                    % Define the properties
                    props = { ...
                        'Tag', ['PatchAnnotation_int-' num2str(intensity)]; ...
                        'XData', XData; ...
                        'YData', YData; ...
                        'FaceColor', Color; ...
                        'LineStyle', '-'; ...
                        'LineWidth', 1; ...
                        'EdgeColor', 'none'; ...
                        'PickableParts', 'none'; ...
                        };
                    % Mount component using the 'mount_patch' function
                    mountComponent(app.MainApp, 'mount_patch', ax, props);
                    % Make sure this annotation object is on the bottom of the axis parent
                    ax.Children = [ax.Children(2:end); ax.Children(1)];
                end
            end
            % ---------------------------------------------------------
            % Acceleration
            % -----
            % Counts
            % -----
            % Set X and YData
            [YData, XData] = selectDataUsingTime(app.MainApp.ACT.metric.acceleration.counts.Data, app.MainApp.ACT.metric.acceleration.counts.Time, StartDate, EndDate);
            YData(end) = NaN;
            % Define the properties
            props = { ...
                'Tag', 'PatchCounts'; ...
                'XData', XData; ...
                'YData', YData+1; ...
                'CData', [YData(2:end)+1; YData(end)]; ...
                'Visible', ifelse(strcmpi(app.MainApp.ACT.display.acceleration.view, 'counts'), 'on', 'off'); ...
                'EdgeColor', 'flat'; ...
                'LineWidth', 1; ...
                'Marker', 'none'; ...
                'CDataMapping', 'scaled'; ...
                'PickableParts', 'none'; ...
                };
            % Mount component using the 'mount_patch' function
            mountComponent(app.MainApp, 'mount_patch', ax, props);
            % -----
            % Euclidean Norm
            % -----
            % Set X and YData
            [YData, XData] = selectDataUsingTime(app.MainApp.ACT.metric.acceleration.bpFiltEuclNorm.Data, app.MainApp.ACT.metric.acceleration.bpFiltEuclNorm.Time, StartDate, EndDate);
            YData(end) = NaN;
            % Define the properties
            props = { ...
                'Tag', 'PatchEuclNorm'; ...
                'XData', XData; ...
                'YData', YData; ...
                'CData', [YData(2:end); YData(end)]; ...
                'Visible', ifelse(strcmpi(app.MainApp.ACT.display.acceleration.view, 'euclNorm'), 'on', 'off'); ...
                'EdgeColor', 'flat'; ...
                'LineWidth', 1; ...
                'Marker', 'none'; ...
                'CDataMapping', 'scaled'; ...
                'PickableParts', 'none'; ...
                };
            % Mount component using the 'mount_patch' function
            mountComponent(app.MainApp, 'mount_patch', ax, props);
            % -----
            % Angle
            % -----
            % Set X and YData
            [YData, XData] = selectDataUsingTime(app.MainApp.ACT.metric.acceleration.angle_z.Data, app.MainApp.ACT.metric.acceleration.angle_z.Time, StartDate, EndDate);
            YData(end) = NaN;
            % Define the properties
            props = { ...
                'Tag', 'PatchAngle'; ...
                'XData', XData; ...
                'YData', YData+360; ...
                'CData', [0; abs(diff([YData(2:end); YData(end)]))]; ...
                'Visible', ifelse(strcmpi(app.MainApp.ACT.display.acceleration.view, 'angle'), 'on', 'off'); ...
                'EdgeColor', 'flat'; ...
                'LineWidth', 1; ...
                'Marker', 'none'; ...
                'CDataMapping', 'scaled'; ...
                'PickableParts', 'none'; ...
                };
            % Mount component using the 'mount_patch' function
            mountComponent(app.MainApp, 'mount_patch', ax, props);
        
        % ---------------------------------------------------------
        % Otherwise: axes contain other data types, e.g. light and temerature
        otherwise
            % ---------------------------------------------------------
            % Data
            % -----
            % Get what fields exist in this data type
            fnames = fieldnames(app.MainApp.ACT.metric.(axesTypes{ai}));
            % For each field ...
            for fi = 1:length(fnames)
                % ... mount/construct a line plot
                % -----
                % Set X and YData
                [YData, XData] = selectDataUsingTime(app.MainApp.ACT.metric.(axesTypes{ai}).(fnames{fi}).Data, app.MainApp.ACT.metric.(axesTypes{ai}).(fnames{fi}).Time, StartDate, EndDate);
                % If the minimum value is zero or smaller, add 0.0001 so the log-scale does not get to -infinity
                YData = ifelse(min(YData) <= 0, YData+0.0001, YData);
                % Define the properties
                props = { ...
                    'Tag', ['PlotData-', axesTypes{ai}, '_field-', fnames{fi}]; ...
                    'XData', XData; ...
                    'YData', YData; ...
                    'Visible', ifelse(app.MainApp.ACT.display.(axesTypes{ai}).field.(fnames{fi}).show, 'on', 'off'); ...
                    'Color', app.MainApp.ACT.display.(axesTypes{ai}).field.(fnames{fi}).clr;
                    'LineWidth', 1; ...
                    };
                % Mount component using the 'mount_plot' function
                mountComponent(app.MainApp, 'mount_plot', ax, props);
            end
            
    end
end

end