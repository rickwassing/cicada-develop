function app_constructDataPanel(app)

% For each day ...
for di = 1:app.ACT.ndays
    % ---------------------------------------------------------
    % Get the new start and end date for this day
    [Position, Title, UserData, StartDate, EndDate] = app_getDataPanelProps(app, di);
    % ---------------------------------------------------------
    % Data UIPanel
    % ---------------------------------------------------------
    % Check if component should mount
    if shouldComponentMount(app, app.DataContainer, ['Panel_day-', num2str(di)])
        % Define the properties
        props = { ...
            'Tag', ['Panel_day-', num2str(di)]; ...
            'Position', Position; ...
            'Title',  Title; ...
            'UserData', UserData; ...
            'FontSize', 8; ...
            'FontWeight', 'bold'; ...
            'BackgroundColor', [0.97, 0.97, 0.97]; ...
            };
        % Mount component
        mountComponent(app, 'mount_uipanel', app.DataContainer, props);
    else
        % Construct the component
        constructComponent(app, ['Panel_day-', num2str(di)], app.DataContainer, { ...
            'Position', Position; ...
            'Title',  Title; ...
            'UserData', UserData; ...
            });
    end
    % -----
    % Extract parent panel object to use for its children
    panel = findobj(app.DataContainer.Children, 'Tag', ['Panel_day-', num2str(di)]);
    % ---------------------------------------------------------
    % Axes, Events, Acceleration, Annotation, Data, Cursor, and Interval
    if any(ismember({'Axes', 'Events', 'Acceleration', 'Annotation', 'Data'}, app.ComponentList))
        % ---------------------------------------------------------
        % Loop over all the axes types ...
        axesTypes = [{'events'}; {'acceleration'}; app.ACT.display.order];
        for ai = 1:length(axesTypes)
            % ... mount/construct the axes
            % ---------------------------------------------------------
            % UIAxes
            % -----
            % Check if component should mount
            if shouldComponentMount(app, panel, ['Axis_day-', num2str(di), '_type-', axesTypes{ai}])
                % Define the properties
                [YLim, YScale, Position] = app_getDataAxisProps(app, axesTypes{ai});
                props = {...
                    'Tag', ['Axis_day-', num2str(di), '_type-', axesTypes{ai}]; ...
                    'XLim', [StartDate, EndDate]; ...
                    'XTick', ceil(StartDate*24+1)/24:1/24:floor(EndDate*24-1)/24; ...
                    'XTickLabel', ifelse(strcmpi(axesTypes{ai}, 'events'), datestr(ceil(StartDate*24+1)/24:1/24:floor(EndDate*24-1)/24, 'HH:MM'), []); ...
                    'XColor', [0.65, 0.68, 0.70]; ...
                    'XGrid', 'on'; ...
                    'GridColor', [0.65, 0.68, 0.70]; ...
                    'GridAlpha', 0.5; ...
                    'YLim', YLim; ...
                    'YTick', []; ...
                    'YScale', YScale; ...
                    'YColor', [0.98, 0.98, 0.98]; ...
                    'Color', [1, 1, 1]; ...
                    'ColorOrder', mount_colororder(); ...
                    'BackgroundColor', [0.97, 0.97, 0.97]; ...
                    'FontSize', 8; ...
                    'Position', Position; ...
                    'Layer', 'top'; ...
                    'Visible', ifelse(Position(4) == 5, 'off', 'on'); ...
                    'Box', 'on'; ...
                    };
                % Mount component using the 'mount_uiaxes' function
                ax = mountComponent(app, 'mount_uiaxes', panel, props, true);
            else
                % Define the properties
                [YLim, YScale, Position] = app_getDataAxisProps(app, axesTypes{ai});
                % Construct the component
                ax = constructComponent(app, ['Axis_day-', num2str(di), '_type-', axesTypes{ai}], panel, {...
                    'XLim', [StartDate, EndDate]; ...
                    'XTick', ceil(StartDate*24+1)/24:1/24:floor(EndDate*24-1)/24; ...
                    'XTickLabel', ifelse(strcmpi(axesTypes{ai}, 'events'), datestr(ceil(StartDate*24+1)/24:1/24:floor(EndDate*24-1)/24, 'HH:MM'), []); ...
                    'YLim', YLim; ...
                    'YScale', YScale; ...
                    'Position', Position; ...
                    'Visible', ifelse(Position(4) == 5, 'off', 'on'); ...
                    });
            end
            % ... and mount/construct its respective components
            switch axesTypes{ai}
                % ---------------------------------------------------------
                % Case 1: axes contain events
                case 'events'
                    if ismember('Events', app.ComponentList)
                        % Extract all events from this start to end date
                        events = selectEventsUsingTime(app.ACT.analysis.events, StartDate, EndDate, 'Enclosed', false);
                        % Assume we do not have to re-order the event components
                        shouldReorder = false;
                        % -----
                        % For each event ...
                        for ei = 1:size(events, 1)
                            % ... mount/construct a patch component
                            if strcmpi(events.label{ei}, 'start')
                                continue
                                % Check if component should mount
                            elseif shouldComponentMount(app, ax, ['Event_day-', num2str(di), '_id-' num2str(events.id(ei))])
                                % Get properties that need more elaborate calculation
                                [Visible, PickableParts, Color, UserData] = app_getEventPatchProps(app, di, events(ei, :));
                                % Set XData
                                XData = [...
                                    events.onset(ei), ...
                                    events.onset(ei), ...
                                    events.onset(ei)+events.duration(ei), ...
                                    events.onset(ei)+events.duration(ei) ...
                                    ];
                                % Define the properties
                                props = {...
                                    'Tag', ['Event_day-', num2str(di), '_id-' num2str(events.id(ei))]; ...
                                    'XData', ifelse(events.duration(ei) == 0, XData(1), XData); ...
                                    'YData', ifelse(events.duration(ei) == 0, 0.5, [0, 1, 1, 0]); ...
                                    'Marker', ifelse(events.duration(ei) == 0, 'v', 'none'); ...
                                    'FaceColor', Color; ...
                                    'EdgeColor', Color; ...
                                    'MarkerFaceColor', Color; ...
                                    'Visible', Visible; ...
                                    'UserData', UserData; ...
                                    'PickableParts', PickableParts; ...
                                    'LineStyle', '-'; ...
                                    'LineWidth', 1; ...
                                    'MarkerEdgeColor', [1, 1, 1]; ...
                                    };
                                % Mount component using the 'mount_patch' function
                                mountComponent(app, 'mount_patch', ax, props);
                                % If we have mounted new components, we'll have to re-order them
                                shouldReorder = true;
                            else
                                % Get properties that need more elaborate calculation
                                [Visible, PickableParts, Color, UserData] = app_getEventPatchProps(app, di, events(ei, :));
                                % Set XData
                                XData = [...
                                    events.onset(ei), ...
                                    events.onset(ei), ...
                                    events.onset(ei)+events.duration(ei), ...
                                    events.onset(ei)+events.duration(ei) ...
                                    ];
                                % Construct the component
                                constructComponent(app, ['Event_day-', num2str(di), '_id-' num2str(events.id(ei))], ax, {...
                                    'XData', ifelse(events.duration(ei) == 0, XData(1), XData); ...
                                    'YData', ifelse(events.duration(ei) == 0, 0.5, [0, 1, 1, 0]); ...
                                    'Marker', ifelse(events.duration(ei) == 0, 'v', 'none'); ...
                                    'FaceColor', Color; ...
                                    'EdgeColor', Color; ...
                                    'MarkerFaceColor', Color; ...
                                    'Visible', Visible; ...
                                    'UserData', UserData; ...
                                    'PickableParts', PickableParts; ...
                                    });
                            end
                        end
                        % If any new components were mounted, we'll have to re-order them
                        if shouldReorder
                            reorderPlotEvents(app, ax);
                        end
                    end
                    
                    % ---------------------------------------------------------
                    % Case 2: axes contain acceleration and annotation
                case 'acceleration'
                    % ---------------------------------------------------------
                    % Annotation
                    if ismember('Annotation', app.ComponentList)
                        % If annotation data exists ...
                        if isfield(app.ACT.analysis.annotate, 'acceleration')
                            % ... Plot the annotation data at each intensity level
                            for intensity = max(app.ACT.analysis.annotate.acceleration.Data):-1:1
                                % Check if component should mount
                                if shouldComponentMount(app, ax, ['PatchAnnotationAcceleration_day-', num2str(di), '_int-' num2str(intensity)])
                                    % Get properties that need more elaborate calculation
                                    [XData, YData, Color] = app_getAnnotationPatchProps(app, 'acceleration', intensity, 4, StartDate, EndDate);
                                    % Define the properties
                                    props = { ...
                                        'Tag', ['PatchAnnotationAcceleration_day-', num2str(di), '_int-' num2str(intensity)]; ...
                                        'XData', XData; ...
                                        'YData', YData; ...
                                        'FaceColor', Color; ...
                                        'LineStyle', '-'; ...
                                        'LineWidth', 1; ...
                                        'EdgeColor', 'none'; ...
                                        'PickableParts', 'none'; ...
                                        };
                                    % Mount component using the 'mount_patch' function
                                    mountComponent(app, 'mount_patch', ax, props);
                                    % Make sure this annotation object is on the bottom of the axis parent
                                    ax.Children = [ax.Children(2:end); ax.Children(1)];
                                else
                                    % Get properties that need more elaborate calculation
                                    [XData, YData, Color] = app_getAnnotationPatchProps(app, 'acceleration', intensity, 4, StartDate, EndDate);
                                    % Construct the component
                                    constructComponent(app, ['PatchAnnotationAcceleration_day-', num2str(di), '_int-' num2str(intensity)], ax, { ...
                                        'XData', XData; ...
                                        'YData', YData; ...
                                        'FaceColor', Color; ...
                                        });
                                end
                            end
                        end
                    end
                    % ---------------------------------------------------------
                    % Acceleration
                    if ismember('Acceleration', app.ComponentList)
                        % -----
                        % Counts
                        % -----
                        % Check if component should mount
                        if shouldComponentMount(app, ax, ['PatchCounts_day-', num2str(di)])
                            % Set X and YData
                            [YData, XData] = selectDataUsingTime(app.ACT.metric.acceleration.counts.Data, app.ACT.metric.acceleration.counts.Time, StartDate, EndDate);
                            if isempty(YData)
                                YData =  [NaN, NaN];
                                XData = [NaN, NaN];
                            else
                                YData(end) = NaN;
                            end
                            % Define the properties
                            props = { ...
                                'Tag', ['PatchCounts_day-', num2str(di)]; ...
                                'XData', XData; ...
                                'YData', YData+1; ...
                                'CData', [YData(2:end)+1; YData(end)]; ...
                                'Visible', ifelse(strcmpi(app.ACT.display.acceleration.view, 'counts'), 'on', 'off'); ...
                                'EdgeColor', 'flat'; ...
                                'LineWidth', 1; ...
                                'Marker', 'none'; ...
                                'CDataMapping', 'scaled'; ...
                                'PickableParts', 'none'; ...
                                };
                            % Mount component using the 'mount_patch' function
                            mountComponent(app, 'mount_patch', ax, props);
                        else
                            % Set X and YData
                            [YData, XData] = selectDataUsingTime(app.ACT.metric.acceleration.counts.Data, app.ACT.metric.acceleration.counts.Time, StartDate, EndDate);
                            if isempty(YData)
                                YData =  [NaN, NaN];
                                XData = [NaN, NaN];
                            else
                                YData(end) = NaN;
                            end
                            % Construct the component
                            constructComponent(app, ['PatchCounts_day-', num2str(di)], ax, { ...
                                'Visible', ifelse(strcmpi(app.ACT.display.acceleration.view, 'counts'), 'on', 'off'); ...
                                'YData', YData+1; ...
                                'XData', XData; ...
                                'CData', [YData(2:end)+1; YData(end)]; ...
                                });
                        end
                        % -----
                        % Euclidean Norm
                        % -----
                        % Check if component should mount
                        if shouldComponentMount(app, ax, ['PatchEuclNorm_day-', num2str(di)])
                            % Set X and YData
                            [YData, XData] = selectDataUsingTime(app.ACT.metric.acceleration.bpFiltEuclNorm.Data, app.ACT.metric.acceleration.bpFiltEuclNorm.Time, StartDate, EndDate);
                            if isempty(YData)
                                YData =  [NaN, NaN];
                                XData = [NaN, NaN];
                            else
                                YData(end) = NaN;
                            end
                            % Define the properties
                            props = { ...
                                'Tag', ['PatchEuclNorm_day-', num2str(di)]; ...
                                'XData', XData; ...
                                'YData', YData; ...
                                'CData', [YData(2:end); YData(end)]; ...
                                'Visible', ifelse(strcmpi(app.ACT.display.acceleration.view, 'euclNorm'), 'on', 'off'); ...
                                'EdgeColor', 'flat'; ...
                                'LineWidth', 1; ...
                                'Marker', 'none'; ...
                                'CDataMapping', 'scaled'; ...
                                'PickableParts', 'none'; ...
                                };
                            % Mount component using the 'mount_patch' function
                            mountComponent(app, 'mount_patch', ax, props);
                        else
                            % Set X and YData
                            [YData, XData] = selectDataUsingTime(app.ACT.metric.acceleration.bpFiltEuclNorm.Data, app.ACT.metric.acceleration.bpFiltEuclNorm.Time, StartDate, EndDate);
                            if isempty(YData)
                                YData =  [NaN, NaN];
                                XData = [NaN, NaN];
                            else
                                YData(end) = NaN;
                            end
                            % Construct the component
                            constructComponent(app, ['PatchEuclNorm_day-', num2str(di)], ax, { ...
                                'Visible', ifelse(strcmpi(app.ACT.display.acceleration.view, 'euclNorm'), 'on', 'off'); ...
                                'YData', YData; ...
                                'XData', XData; ...
                                'CData', [YData(2:end); YData(end)]; ...
                                });
                        end
                        % -----
                        % Angle
                        % -----
                        % Check if component should mount
                        if shouldComponentMount(app, ax, ['PatchAngle_day-', num2str(di)])
                            % Set X and YData
                            [YData, XData] = selectDataUsingTime(app.ACT.metric.acceleration.angle_z.Data, app.ACT.metric.acceleration.angle_z.Time, StartDate, EndDate);
                            if isempty(YData)
                                YData =  [NaN, NaN];
                                XData = [NaN, NaN];
                            else
                                YData(end) = NaN;
                            end
                            % Define the properties
                            props = { ...
                                'Tag', ['PatchAngle_day-', num2str(di)]; ...
                                'XData', XData; ...
                                'YData', YData+360; ...
                                'CData', [0; abs(diff([YData(2:end); YData(end)]))]; ...
                                'Visible', ifelse(strcmpi(app.ACT.display.acceleration.view, 'angle'), 'on', 'off'); ...
                                'EdgeColor', 'flat'; ...
                                'LineWidth', 1; ...
                                'Marker', 'none'; ...
                                'CDataMapping', 'scaled'; ...
                                'PickableParts', 'none'; ...
                                };
                            % Mount component using the 'mount_patch' function
                            mountComponent(app, 'mount_patch', ax, props);
                        else
                            % Set X and YData
                            [YData, XData] = selectDataUsingTime(app.ACT.metric.acceleration.angle_z.Data, app.ACT.metric.acceleration.angle_z.Time, StartDate, EndDate);
                            if isempty(YData)
                                YData =  [NaN, NaN];
                                XData = [NaN, NaN];
                            else
                                YData(end) = NaN;
                            end
                            % Construct the component
                            constructComponent(app, ['PatchAngle_day-', num2str(di)], ax, { ...
                                'Visible', ifelse(strcmpi(app.ACT.display.acceleration.view, 'angle'), 'on', 'off'); ...
                                'YData', YData+360; ...
                                'XData', XData; ...
                                'CData', [0; abs(diff([YData(2:end); YData(end)]))]; ...
                                });
                        end
                    end
                    % ---------------------------------------------------------
                    % Otherwise: axes contain other data types, e.g. light and temerature
                otherwise
                    % ---------------------------------------------------------
                    % Data
                    if ismember('Data', app.ComponentList) || ismember('Annotation', app.ComponentList)
                        % -----
                        % ... mount/construct annotation patches, if annotation data exists ...
                        if ismember('Annotation', app.ComponentList) && isfield(app.ACT.analysis.annotate, axesTypes{ai})
                            % ... Plot the annotation data at each intensity level
                            intLvls = unique(app.ACT.analysis.annotate.(axesTypes{ai}).Data);
                            intLvls(intLvls == 0) = []; % zero willjust be white
                            intLvls(isnan(intLvls)) = []; % nan values are to be excluded
                            for intensity = max(intLvls):-1:min(intLvls)
                                % -----
                                % Check if component should mount
                                if shouldComponentMount(app, ax, ['PatchAnnotation' titleCase(axesTypes{ai}) '_int-' num2str(intensity)])
                                    % Get properties that need more elaborate calculation
                                    [XData, YData, Color] = app_getAnnotationPatchProps(app, axesTypes{ai}, intensity, length(intLvls), StartDate, EndDate);
                                    % Define the properties
                                    props = { ...
                                        'Tag', ['PatchAnnotation' titleCase(axesTypes{ai}) '_int-' num2str(intensity)]; ...
                                        'XData', XData; ...
                                        'YData', YData; ...
                                        'FaceColor', Color; ...
                                        'LineStyle', '-'; ...
                                        'LineWidth', 1; ...
                                        'EdgeColor', 'none'; ...
                                        'PickableParts', 'none'; ...
                                        };
                                    % Mount component using the 'mount_patch' function
                                    mountComponent(app, 'mount_patch', ax, props);
                                    % Make sure this annotation object is on the bottom of the axis parent
                                    ax.Children = [ax.Children(2:end); ax.Children(1)];
                                else
                                    % Get properties that need more elaborate calculation
                                    [XData, YData, Color] = app_getAnnotationPatchProps(app, axesTypes{ai}, intensity, length(intLvls), StartDate, EndDate);
                                    % Construct the component
                                    constructComponent(app, ['PatchAnnotation' titleCase(axesTypes{ai}) '_int-' num2str(intensity)], ax, { ...
                                        'XData', XData; ...
                                        'YData', YData; ...
                                        'FaceColor', Color; ...
                                        });
                                end
                            end 
                        end
                        % ---------------------------------------------------------
                        % Data
                        % -----
                        if ismember('Data', app.ComponentList)
                            % Get what fields exist in this data type
                            fnames = fieldnames(app.ACT.metric.(axesTypes{ai}));
                            % For each field ...
                            for fi = 1:length(fnames)
                                % -----
                                % ... mount/construct a line plot
                                % -----
                                % Check if component should mount
                                if shouldComponentMount(app, ax, ['PlotData-', axesTypes{ai}, '_field-', fnames{fi}, '_day-', num2str(di)])
                                    % Set X and YData
                                    [YData, XData] = selectDataUsingTime(app.ACT.metric.(axesTypes{ai}).(fnames{fi}).Data, app.ACT.metric.(axesTypes{ai}).(fnames{fi}).Time, StartDate, EndDate);
                                    if isempty(YData)
                                        continue
                                    end
                                    % If the minimum value is zero or smaller, add 0.0001 so the log-scale does not get to -infinity
                                    YData = ifelse(min(YData) <= 0, YData+0.0001, YData);
                                    % Define the properties
                                    props = { ...
                                        'Tag', ['PlotData-', axesTypes{ai}, '_field-', fnames{fi}, '_day-', num2str(di)]; ...
                                        'XData', XData; ...
                                        'YData', YData; ...
                                        'Visible', ifelse(app.ACT.display.(axesTypes{ai}).field.(fnames{fi}).show, 'on', 'off'); ...
                                        'Color', app.ACT.display.(axesTypes{ai}).field.(fnames{fi}).clr;
                                        'LineWidth', 1; ...
                                        };
                                    % Mount component using the 'mount_plot' function
                                    mountComponent(app, 'mount_plot', ax, props);
                                else
                                    % Set X and YData
                                    [YData, XData] = selectDataUsingTime(app.ACT.metric.(axesTypes{ai}).(fnames{fi}).Data, app.ACT.metric.(axesTypes{ai}).(fnames{fi}).Time, StartDate, EndDate);
                                    if isempty(YData)
                                        continue
                                    end
                                    % If the minimum value is zero or smaller, add 0.0001 so the log-scale does not get to -infinity
                                    YData = ifelse(min(YData) <= 0, YData+0.0001, YData);
                                    % Construct the component
                                    constructComponent(app, ['PlotData-', axesTypes{ai}, '_field-', fnames{fi}, '_day-', num2str(di)], ax, { ...
                                        'XData', XData; ...
                                        'YData', YData; ...
                                        'Visible', ifelse(app.ACT.display.(axesTypes{ai}).field.(fnames{fi}).show, 'on', 'off'); ...
                                        'Color', app.ACT.display.(axesTypes{ai}).field.(fnames{fi}).clr;
                                        });
                                end
                            end
                        end
                        app_reorderPlotComponents(app, ax, axesTypes{ai}, di)
                    end
            end
        end
    end
end

end